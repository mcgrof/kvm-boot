#!/bin/bash
# Copyright (C) 2017-2018 Luis R. Rodriguez <mcgrof@kernel.org>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of copyleft-next (version 0.3.1 or later) as published
# at http://copyleft-next.org/.

KVM_BOOT_DEBUG_TMP=$(mktemp -d)
KVM_BOOT_VERBOSE="false"

setup_finish()
{
	if [ -d $KVM_BOOT_DEBUG_TMP ]; then
		rm -rf $KVM_BOOT_DEBUG_TMP
	fi
}

trap "setup_finish" EXIT

function setup_headers()
{
	if [ -z $KVM_BOOT_LIB_DIR ]; then
		KVM_BOOT_LIB_DIR=$(dirname $0)
	fi
	source $KVM_BOOT_LIB_DIR/kvm_boot_lib.sh
}

function allow_user_defaults_network()
{
	if [ -z $KVM_BOOT_NETDEV ]; then
		KVM_BOOT_NETDEV=wlp3s0
	fi

	if [ -z $KVM_BOOT_TAP_DEV ]; then
		KVM_BOOT_TAP_DEV=tap0
	fi

	# Network information, these are sane values, you can keep them
	# unless they intefere with your network, ie, if you already make use
	# of this subnet. If you don't use this subnet it should be fine.
	if [ -z $KVM_BOOT_NETWORK ]; then
		KVM_BOOT_NETWORK=192.168.53.0
	fi

	if [ -z $KVM_BOOT_NETMASK ]; then
		KVM_BOOT_NETMASK=255.255.255.0
	fi

	if [ -z $KVM_BOOT_GATEWAY ]; then
		KVM_BOOT_GATEWAY=192.168.53.1
	fi

	if [ -z $KVM_BOOT_DHCPRANGE ]; then
		KVM_BOOT_DHCPRANGE=192.168.53.2,192.168.53.254
	fi

	if [ -z $KVM_BOOT_DNSMASQ_RUN_DIR ]; then
		KVM_BOOT_DNSMASQ_RUN_DIR=/var/run/dnsmasq
	fi

	if [ -z $KVM_BOOT_DNSMASQ_PID ]; then
		KVM_BOOT_DNSMASQ_PID=$KVM_BOOT_DNSMASQ_RUN_DIR/qemu-dnsmasq-$KVM_BOOT_TAP_DEV.pid
	fi

	if [ -z $KVM_BOOT_VDE_SWITCH_PID ]; then
		KVM_BOOT_VDE_SWITCH_PID=/var/run/qemu-vde.pid
	fi

	if [ -z $KVM_BOOT_DNSMASQ_LEASE ]; then
		KVM_BOOT_DNSMASQ_LEASE=/var/lib/misc/qemu-dnsmasq-$KVM_BOOT_TAP_DEV.leases
	fi

	# Optionally parameters to enable PXE support
	if [ -z $KVM_BOOT_TFTPROOT ]; then
		KVM_BOOT_TFTPROOT=
	fi

	if [ -z $KVM_BOOT_BOOTP ]; then
		KVM_BOOT_BOOTP=
	fi

	if [ -z $KVM_BOOT_FIX_DNSMASQ_CONFLICT ]; then
		KVM_BOOT_FIX_DNSMASQ_CONFLICT="false"
	fi

	KVM_BOOT_SYSTEMD_USED="false"
	ps -ef | grep -q systemd
	if [ $? -eq 0 ]; then
		KVM_BOOT_SYSTEMD_USED="true"
	fi

	KVM_BOOT_SYSTEMD_DNSMASQ_DIR=""
	if [ "$KVM_BOOT_SYSTEMD_USED" = "true" ]; then
		KVM_BOOT_SYSTEMD_DNSMASQ_DIR=$(systemctl status dnsmasq.service | grep "\-7" | awk -F"-7" '{print $2}' | awk '{print $1}' | awk -F"," '{print $1}')
		if [ ! -d $KVM_BOOT_SYSTEMD_DNSMASQ_DIR ]; then
			KVM_BOOT_SYSTEMD_DNSMASQ_DIR=""
		fi
	fi
}

do_ifconfig() {
    IFCONFIG_DEV=$1
    IFCONFIG_IP=$2
    IFCONFIG_NETMASK=$4
 
    which ip 2>&1 > /dev/null
    if [ $? -eq 0 ]; then
	     if [ "$KVM_BOOT_VERBOSE" = "true" ]; then
		echo Calling
		echo ip addr add $IFCONFIG_IP/$IFCONFIG_NETMASK dev $IFCONFIG_DEV
		echo ip link set dev $IFCONFIG_DEV up
	    fi
	    ip addr add $IFCONFIG_IP/$IFCONFIG_NETMASK dev $IFCONFIG_DEV
	    ip link set dev $IFCONFIG_DEV up
    else
	if [ "$KVM_BOOT_VERBOSE" = "true" ]; then
    		echo Calling:
		echo ifconfig "$@"
	fi
	ifconfig "$@"
    fi
}

do_iptables_restore() {
    iptables-restore "$@"
}

do_dnsmasq() {
	if [ -f $KVM_BOOT_DNSMASQ_PID ]; then
		echo "dnsmasq already running, try $0 -r"
		exit
	fi

	if [ "$KVM_BOOT_VERBOSE" = "true" ]; then
		echo Running:
		echo dnsmasq "$@"
	fi
	dnsmasq "$@" 2> $KVM_BOOT_DEBUG_TMP/log
	RET=$?
	if [ $RET -ne 0 ]; then
		grep -q "Address already in use" $KVM_BOOT_DEBUG_TMP/log
		# If we failed to start with an error return value of
		# 2, you are on a systemd system and the error message
		# says address is already in use, chances are high your
		# distribution uses dnsthmasq for caching purposes and
		# dnsmasq won't run as the wild card effort by default
		# will force the distribution instance of dnsmasq to
		# run on our shiny tap interface. We need to be
		# specific and force dnsmasq from the distribution and
		# use *both* bind-interfaces and except-interface so that
		# it won't start a dns service on our tap interface. Below we
		# provide a fix but only for systemd systems.
		if [[ $RET -eq 2 && $? -eq 0 ]]; then
			# At least Debian testing uses this.
			if [[ "$KVM_BOOT_SYSTEMD_USED" = "true" && \
			      "$KVM_BOOT_FIX_DNSMASQ_CONFLICT" = "true" && \
			      "$KVM_BOOT_SYSTEMD_USED" != "" ]]; then
				KVM_BOOT_DISTRO_DNSMASQ_CONF_FIX="$KVM_BOOT_SYSTEMD_DNSMASQ_DIR/kvm-boot"
				if [ ! -f $KVM_BOOT_DISTRO_DNSMASQ_CONF_FIX ]; then
					echo bind-interfaces > $KVM_BOOT_DISTRO_DNSMASQ_CONF_FIX
					echo except-interface=$KVM_BOOT_TAP_DEV >> $KVM_BOOT_DISTRO_DNSMASQ_CONF_FIX
					systemctl restart dnsmasq.service
				fi

				# Try again
				dnsmasq "$@" 2> $KVM_BOOT_DEBUG_TMP/log
				RET=$?
				if [ $RET -ne 0 ]; then
					echo "Failed to start dnsmasq, (return $RET) and failed to fix your problem for you"
					echo "Check your other dnsmasq instances running and ensure they have"
					echo "bind-interfaces on its configuration."
					exit 1
				else
					echo "Fixed your already running dnsmasq.service to use"
					echo "bind-interfaces and use except-interface=$KVM_BOOT_TAP_DEV"
					echo "If you want to modify this later, the configuration file is:"
					echo
					echo "$KVM_BOOT_DISTRO_DNSMASQ_CONF_FIX"
					echo
				fi
			else
				echo "You have another dnsmasq instance running which binds to any interface spawned"
				echo "To use $0 you must fix this by adding 'bind-interfaces' to its configuration."
				echo "Restart that instance with this and try again"
				exit 1
			fi
		fi
	fi
	echo "dnsmasq for kvm-boot spawned successfully!"
}

enable_ip_forward() {
	sysctl -w net.ipv4.ip_forward=1
}

flush_tables()
{
	for i in INPUT FORWARD OUTPUT; do
		iptables -F $i
	done
	iptables -t nat -D POSTROUTING 1 2>/dev/null
}

add_filter_rules()
{
	flush_tables
	echo Calling:
	if [ ! -z $KVM_BOOT_NETDEV_VPN ]; then
		echo iptables -t nat -A POSTROUTING -s $KVM_BOOT_NETWORK/24 -o $KVM_BOOT_NETDEV_VPN -j MASQUERADE
		iptables -t nat -A POSTROUTING -s $KVM_BOOT_NETWORK/24 -o $KVM_BOOT_NETDEV_VPN -j MASQUERADE
	fi
	echo iptables -t nat -A POSTROUTING -s $KVM_BOOT_NETWORK/24 -o $KVM_BOOT_NETDEV -j MASQUERADE
	iptables -t nat -A POSTROUTING -s $KVM_BOOT_NETWORK/24 -o $KVM_BOOT_NETDEV -j MASQUERADE
}

start_dnsmasq() {
    do_dnsmasq \
	--strict-order \
	--log-queries \
	--except-interface=lo \
	--no-dhcp-interface=$KVM_BOOT_NETDEV \
	--interface=$1 \
	--listen-address=$KVM_BOOT_GATEWAY \
	--bind-interfaces \
	--dhcp-range=$KVM_BOOT_DHCPRANGE \
	--conf-file="" \
	--dhcp-no-override \
	--dhcp-leasefile=$KVM_BOOT_DNSMASQ_LEASE \
	--pid-file=$KVM_BOOT_DNSMASQ_PID \
	${KVM_BOOT_TFTPROOT:+"--enable-tftp"} \
	${KVM_BOOT_TFTPROOT:+"--tftp-root=$KVM_BOOT_TFTPROOT"} \
	${KVM_BOOT_BOOTP:+"--dhcp-boot=$KVM_BOOT_BOOTP"}
}

do_vdeswitch() {
	# vde_switch in a daemon mode enters into an interactive
	# shell which you can use. We put that session into a screen
	# session which you can later attach to if you want.
	if [ ! -f $KVM_BOOT_VDE_SWITCH_PID ]; then
		if [ "$KVM_BOOT_VERBOSE" = "true" ]; then
			echo Calling:
			echo vde_switch "$@"
		fi

		# XXX: I can't find this screen session though :(
		#export SCREENDIR=/run/screen/S-root
		screen -S switch -dm vde_switch "$@"
		if [ $? -ne 0 ]; then
			echo "Failed to start vde_switch ... return value: $?"
			exit
		fi
	else
		PID="$(cat $KVM_BOOT_VDE_SWITCH_PID)"
		echo "vde_switch is already running on pid $PID, try running"
		echo "$0 with -r to reset fully".
		exit 1
	fi
}

start_vdeswitch() {
    LOOPS=4
    TRY=0

    do_vdeswitch \
	-daemon \
	-hub \
	-tap $KVM_BOOT_TAP_DEV \
	-mod 660 \
	-group kvm \
	-s $KVM_BOOT_VDE_SOCKET \
	--pidfile $KVM_BOOT_VDE_SWITCH_PID

    while [[ $TRY -lt $LOOPS ]]; do
	    if [ ! -f $KVM_BOOT_VDE_SWITCH_PID ]; then
		    echo "Waiting for $KVM_BOOT_VDE_SWITCH_PID ..."
		    sleep 1
		    let TRY=$TRY+1
	    else
		echo "vde_switch ready!"
		break
	    fi
    done

    if [ ! -f $KVM_BOOT_VDE_SWITCH_PID ]; then
	    echo "vde_switch process never started, bailing ... debug your setup"
	    exit
    fi
}

setup_nat() {
	enable_ip_forward
	add_filter_rules "$1"
}

kill_setup()
{
	if [ -f $KVM_BOOT_DNSMASQ_PID ]; then
		PID="$(cat $KVM_BOOT_DNSMASQ_PID)"
		echo "Going to try to kill dnsmasq pid $PID"
		kill -9 $PID 2>/dev/null
		rm -f $KVM_BOOT_DNSMASQ_PID
	fi

	if [ -f $KVM_BOOT_VDE_SWITCH_PID ]; then
		PID="$(cat $KVM_BOOT_VDE_SWITCH_PID)"
		echo "Going to try to kill vde_switch pid $PID"
		kill -9 $PID 2>/dev/null
		rm -f $KVM_BOOT_VDE_SWITCH_PID
	fi

	# Killing the vde_switch process should kill the
	# device, but just in case, nuke try nuking the device
	# as well.
	ip link show $KVM_BOOT_TAP_DEV 2> /dev/null
	if [ $? -eq 0 ]; then
		ip link delete $KVM_BOOT_TAP_DEV
		if [ "$KVM_BOOT_VERBOSE" = "true" ]; then
			echo ip link delete $KVM_BOOT_TAP_DEV
		fi
	fi
	flush_tables
	rm -rf $KVM_BOOT_VDE_SOCKET
}

parse_args()
{
	while [[ ${#1} -gt 0 ]]; do
		key="$1"

		case $key in
		-r)
			echo "Reset switch"
			kill_setup
			shift
			;;
		-k)
			echo "Killing all prior setup"
			kill_setup
			exit
			;;
		-v)
			KVM_BOOT_VERBOSE="true"
			shift
			;;
		*)
			shift
			;;
		esac
	done
}

setup_headers
allow_user_defaults
allow_user_defaults_network

parse_args $@

echo Setting up switch on $KVM_BOOT_TAP_DEV

start_vdeswitch
do_ifconfig $KVM_BOOT_TAP_DEV "$KVM_BOOT_GATEWAY" netmask "$KVM_BOOT_NETMASK" up

setup_nat $KVM_BOOT_TAP_DEV
start_dnsmasq $KVM_BOOT_TAP_DEV
